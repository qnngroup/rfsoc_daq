// ragged_sample_combiner.sv - Reed Foster
// submodule of on-the-fly sparse signal synthesis
// required to combine ragged collections of samples which may be in groups
// that are not of size PARALLEL_SAMPLES
// source of samples are those generated by interpolator and those from the
// buffer of dense sample sequences

module ragged_sample_combiner #(
  parameter int PARALLEL_SAMPLES = 32, // 6.144 GS/s @ 384 MHz, one transfer every other cycle
  parameter int SAMPLE_WIDTH = 16 // 14-bit DAC
) (
  input wire clk, reset,

  Axis_If.Slave_Simple data_in, // {size, samples}
  Axis_If.Master_Simple data_out
);

localparam int SHIFTREG_LENGTH = 2*PARALLEL_SAMPLES - 1;
// latency of each shift register is at most PARALLEL_SAMPLES - 1 and need to output 1 transfer per cycle
localparam int NUM_SHIFTREGS = PARALLEL_SAMPLES - 1;
localparam int OFFSET_WIDTH = $clog2(PARALLEL_SAMPLES);

logic [PARALLEL_SAMPLES*SAMPLE_WIDTH-1:0] samples_in;
logic [$clog2(PARALLEL_SAMPLES)-1:0] size_in;

assign samples_in = data_in.data[PARALLEL_SAMPLES*SAMPLE_WIDTH-1:0];
assign size_in = data_in.data[PARALLEL_SAMPLES*SAMPLE_WIDTH+:$clog2(PARALLEL_SAMPLES)];

// how much data in shift register should be shifted
logic [NUM_SHIFTREGS-1:0][OFFSET_WIDTH:0] next_offset; // pipeline register (extra bit to track when we overflow the shift register)
logic [NUM_SHIFTREGS-1:0][OFFSET_WIDTH-1:0] shift_amount; // counter to track how much each register has been shifted
logic [NUM_SHIFTREGS-1:0] lsbs_complete, lsbs_complete_d; // if we have enough bits, output a full word, otherwise just cascade what we have so far
logic [NUM_SHIFTREGS-1:0][PARALLEL_SAMPLES*SAMPLE_WIDTH-1:0] lsbs_masked, msbs_masked;

logic [$clog2(NUM_SHIFTREGS)-1:0] shiftreg_write_select, shiftreg_read_select;

logic [NUM_SHIFTREGS-1:0][SHIFTREG_LENGTH*SAMPLE_WIDTH-1:0] shiftreg_data;
logic [NUM_SHIFTREGS-1:0][SHIFTREG_LENGTH-1:0] shiftreg_mask;

always_ff @(posedge clk) begin
  if (reset) begin
    shiftreg_mask <= '0;
    next_offset <= '0;
    shift_amount <= '0;
    complete_word <= '0;
  end else begin
    if (data_in.ok) begin
      // put data in LSBs of shift register
      shiftreg_data[shiftreg_write_select][PARALLEL_SAMPLES*SAMPLE_WIDTH-1:0] <= samples_in;
      // mask of which bits are valid
      for (int i = 0; i < SHIFTREG_LENGTH; i++) begin
        shiftreg_mask[shiftreg_write_select][i] <= i < size_in;
      end
      // update shift amount
      if (shiftreg_write_select == 0) begin
        // wrap prev/next next_offset information from final shift register
        shift_amount[shiftreg_write_select] <= next_offset[NUM_SHIFTREGS-1] % SHIFTREG_LENGTH;
        next_offset[shiftreg_write_select] <= size_in + next_offset[NUM_SHIFTREGS-1];
        lsbs_complete[shiftreg_write_select] <= next_offset[NUM_SHIFTREGS-1] > SHIFTREG_LENGTH;
      end else begin
        shift_amount[shiftreg_write_select] <= next_offset[shiftreg_write_select-1] % SHIFTREG_LENGTH;
        next_offset[shiftreg_write_select] <= size_in + next_offset[shiftreg_write_select-1];
        lsbs_complete[shiftreg_write_select] <= next_offset[shiftreg_write_select-1] > SHIFTREG_LENGTH;
      end
      // update write pointer to next shift register
      if (shiftreg_write_select == NUM_SHIFTREGS - 1) begin
        shiftreg_write_select <= 0;
      end else begin
        shiftreg_write_select <= shiftreg_write_select + 1'b1;
      end
    end
    // update all shift registers except for the one being written to
    for (int sr = 0; sr < NUM_SHIFTREGS; sr++) begin
      if (sr != shiftreg_write_select) begin
        // shift data
        if (shift_amount[sr] != 0) begin
          shift_amount[sr] <= shift_amount[sr] - 1'b1;
          shiftreg_data[sr] <= {shiftreg_data[sr], {PARALLEL_SAMPLES{1'b0}}};
          shiftreg_mask[sr] <= {shiftreg_mask[sr], 1'b0};
        end else begin
          shiftreg_data[sr]
        end
      end
    end
    // read output of shift register
    //shiftreg_
  end
end

endmodule
